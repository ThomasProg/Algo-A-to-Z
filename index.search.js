var relearn_search_index=[{content:` Hyperplane Separation Theorem For 2D Theorem: If two convex shapes do not collide, then, a straight line can separate them.
Contrapositive: If two convex shapes collide, then, there is no straight line separating them.
For 3D Theorem: If two convex shapes do not collide, then, a plane can separate them.
Contrapositive: If two convex shapes collide, then, there is no plane separating them.
Generalization for higher dimensions Theorem: If two convex shapes do not collide, then, a hyperplane can separate them.
Contrapositive: If two convex shapes collide, then, there is no hyperplane separating them.
Examples : A straight line separates the shapes, so there are no collisions No straight line separates the shapes, so there is a collision The shape on the right is not convex, the theorem doesn't work Separating Axis Theorem Definition : Statement: The line, plane, or hyperplane described above always has a normal axis.
Theorem: If the shapes are not colliding, the projections of the shapes on this axis do not overlap.
Contrapositive: If the shapes are colliding, then, no matter the axis we take, the projections of the shapes on this axis will overlap Warning Whether there are collisions or not, there will always exist an axis for which the projections of the shapes overlap. Examples : The separating straight line has a normal axis We project the shapes on the axis Their projections do not overlap :\u003c/br\u003e there are no collisions! No straight line separates the shapes, so there is a collision There is always an axis for which projections overlap `,description:"",tags:null,title:"Theory",uri:"/collisions/narrowphase/sat/theory/index.html"},{content:` The brute force way We can project these shapes on every axis imaginable. If on one axis, the projections do not overlap, then there are no collisions. Otherwise, there is a collision.
C++ Python bool TestCollisionsWithSAT(const Shape\u0026 shape1, const Shape\u0026 shape2) { std::vector\u003cVector\u003e axes = GetEveryAxisInTheWholeWorld(); for (const Vector\u0026 axis : axes) { Range projection1 = shape1.ProjectOnAxis(axis); Range projection2 = shape2.ProjectOnAxis(axis); // if there is a separating hyperplane if (!DoRangesOverlap(projection1, projection2)) { // then there is no collision return false; } } return true; } def TestCollisionsWithSAT(shape1: Shape, shape2: Shape) -\u003e bool axes = GetEveryAxisInTheWholeWorld() for axis in axes: projection1 = shape1.ProjectOnAxis(axis) projection2 = shape2.ProjectOnAxis(axis) # if there is a separating hyperplane if not DoRangesOverlap(projection1, projection2): # then there is no collision return False return True Vector can be a 2D vector or a 3D vector depending on the dimension you are implementing the algorithm in.
ProjectOnAxis() can vary and be optimized depending on the implentation of Shape.
GetEveryAxisInTheWholeWorld() returns a list of every axis possibly existing (which will, of course, be a bottleneck).
The implementation of Range and DoRangesOverlap is pretty straight forward:
C++ Python C# Java struct Range { float min, max; }; bool DoRangesOverlap(const Range\u0026 range1, const Range\u0026 range2) { return range1.max \u003e range2.min \u0026\u0026 range2.max \u003e range1.min; } class Range(): min = 0 max = 0 def DoRangesOverlap(range1: Range, range2: Range) -\u003e bool: return range1.max \u003e range2.min and range2.max \u003e range1.min public struct Range { public float min; public float max; public static bool DoRangesOverlap(Range range1, Range range2) { return range1.max \u003e range2.min \u0026\u0026 range2.max \u003e range1.min; } }; public class Range { public float min; public float max; public static bool DoRangesOverlap(Range range1, Range range2) { return range1.max \u003e range2.min \u0026\u0026 range2.max \u003e range1.min; } }; The smarter way GetEveryAxisInTheWholeWorld() will, of course, make the algorithm too slow to be used. However, we actually don’t have to check every axis.
ProjectOnAxis() can also be optimized.
More informations on that in the next chapters.
`,description:"",tags:null,title:"In practice",uri:"/collisions/narrowphase/sat/inpractice/index.html"},{content:` Non unit axes optimization On the previous examples, for the projection to be accurate, the axes had to be unit vectors.
Let’s asssume an axis is not unit vectors.
That would mean all projections on that axis would be multiplied by the length of that axis.
However, the length of that axis is constant.
This means that the order of the projections are still preserved.
Since we’re only using that order, and not the values in themselves, we can take advantage of that.
Brute force way For 2D : Python def GetEveryAxisInTheWholeWorld(precision) axes = [] mult = 2 * Math.PI / precision for i in range(precision): angle = i * mult axes.append(Vector2D(cos(angle), sin(angle)) return axes For other dimensions : We just have to get axes at a regular interval in a hypersphere.
The smart way Let’s take the shortest path between the two shapes.
If the shapes are colliding, then the length of that path should be 0.
Else, it is not 0.
That means the separating axis will always be linear to that shortest path.
We can also extend the features:
2D+ : we can extend an edge to a line, since the shortest distance between a point and that line wouldn’t change 3D+ : we can extend an face to a plane, since the shortest distance between a point and that plane wouldn’t change etc For 2D : In 2D, we have to compute the axis of the shortest path between:
a point and another point a line and another line a point and a line 2D : A point and a point Let v1, v2 be two points. The axis of the shortest path between v1 and v2 is v2-v1.
However, since points are infinitesimal, we assume this collision never happens.
Even if it ends up happening, the algorithm will detect a collision between a line and a line.
It is an imprecision that can be discarded.
We can discard this case.
2D : A line and a line If the two edges weren’t parallel, the shortest path would be between a vertex and an edge instead.
So we can assume that the lines are parallel.
If that is the case, then the axis of their shortest path is just the normal of that line.
2D : a point and a line The shortest path between a line and a line is a straight line orthogonal to the line.
So the separating axis is just the normal of the line.
Code Python def GetNormal(vector: Vector2) -\u003e Vector2: return Vector2(- vector.y, vector.x) def GetPotentialSeparatingAxesFor1Shape(shape): axes = [] nbVertices = len(shape.vertices) for i in range(nbVertices - 1): side = shape.vertices[i] - shape.vertices[i+1] axes.append(GetNormal(side)) lastSide = shape.vertices[nbVertices - 1] - shape.vertices[0] axes.append(GetNormal(lastSide)) return axes def GetPotentialSeparatingAxes(shape1, shape2): axes = [] axes.append(GetPotentialSeparatingAxesFor1Shape(shape1)) axes.append(GetPotentialSeparatingAxesFor1Shape(shape2)) return axes For 3D : In 3D, we have to compute the axis of the shortest path between:
a point and a point (infinitesimal, discarded) a point and a line (infinitesimal, discarded) a plane and a plane a plane and a point a plane and a line a line and a line 3D : A plane and a plane Same logic as for the lines in 2D.
They must be parallel. Otherwise, we would test with another feature.
If they are, then the axis would be the normal of either of the planes.
3D : A plane and a point We can just use the normal of the plane.
3D : A plane and a line The line is parallel to the plane.
Otherwise, we would test the collision between a line and a line.
If they are, then the axis would be the normal of the plane.
3D : A line and a line If the lines are parallel, we can assume their collision is infinitesimal and discard it.
So we will assume they are not.
If that is the case, then the axis of their shortest path would be the crossproduct between their two directions.
Code Python def CrossProduct(vector1: Vector3, vector2: Vector3) -\u003e Vector3: result = Vector3() result.x = vector1.y * vector2.z - vector1.z * vector2.y result.y = vector1.z * vector2.x - vector1.x * vector2.z result.x = vector1.x * vector2.y - vector1.y * vector2.x return result def GetNormal(vector1: Vector3, vector2: Vector3) -\u003e Vector3: return CrossProduct(vector1, vector2) def GetPotentialSeparatingAxesFor1Shape(shape): axes = [] triangles = shape.GetAllTriangles() for triangle in triangles: axes.append(GetNormal(triangle.edge1, triangle.edge2)) return axes def GetPotentialSeparatingAxes(shape1, shape2): axes = [] # Plane/Plane and Line/Plane cases axes.append(GetPotentialSeparatingAxesFor1Shape(shape1)) axes.append(GetPotentialSeparatingAxesFor1Shape(shape2)) # Line/Line case edgesShape1 = shape1.GetAllEdges() edgesShape2 = shape1.GetAllEdges() for edgeShape1 in edgesShape1: for edgeShape2 in edgesShape2: axes.append(CrossProduct(edgeShape1, edgeShape2)) return axes Generalization : Let’s define hyperplanes dimensions:
A line is a 2D hyperplane A plane is a 3D hyperplane etc For simplicity, let H(N) be a N dimensional hyperplane.
Let D be the dimension of the space.
We have to test:
H(D) / H(i), i \u003c= D H(D-1) / H(D) H(D-1) / H(D-1) etc H(D) / H(i), i \u003c= D We can just take the normal of H(D).
H(i) / H(j) As long as the direct sum of H(i) and H(j) is equal to H(N), we can compute a vector orthogonal to both H(i) and H(j).
Otherwise, we can consider it as infinitesimal, and discard it.
Parallel axes optimization If two axes are parallel, then we only need to test with one of those.\\
It is important for symetric shapes, such as rectangles, circles, spheres, etc.
`,description:"",tags:null,title:"Get Projection Axes",uri:"/collisions/narrowphase/sat/getprojectionaxes/index.html"},{content:` Projecting a point The dot product can be used to project a point on an axis. Python def ProjectPointOnAxis(point, axis) -\u003e float: return DotProduct(point, axis); 2D Dot Product Python def DotProduct(v1, v2) -\u003e float: return v1.x * v2.x + v1.y * v2.y 3D Dot Product Python def DotProduct(v1, v2) -\u003e float: return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z Dot Product Generalization Python def DotProduct(v1, v2) -\u003e float: nbDimensions = v1.GetDimension() total = 0 for i in range(nbDimensions): total += v1.coords[i] * v2.coords[i] return total Projecting a circle, sphere, or hypersphere To simulate an hypersphere, we usually make models with a lot of triangles and vertices.
This is one of the best ways we know to render hyperspheres with other objects.
However, for collisions, we do not need this representation, since it only makes the performance worse.
Instead, we can just use the mathematical properties of the hypersphere and have O(1) performance.
Python def ProjectSphereOnAxis(hyperSphere: HyperSphere, axis: Vector) -\u003e Range: centerProj = ProjectPointOnAxis(hyperSphere.center, axis.normalized()) range = new Range() range.min = centerProj - hyperSphere.radius range.max = centerProj + hyperSphere.radius return range Projecting a polygon Mostly used shapes are models composed of vertices.
The projection of all the points of an edge is equal to the range of the projection of its two vertices.
Python def ProjectShapeOnAxis(shape: Shape, axis: Vector) -\u003e Range: range = new Range() range.min = Math.max() range.max = Math.min() for vertex in shape.vertices: proj = ProjectPointOnAxis(vertex, axis) if (proj \u003c range.min): range.min = proj if (proj \u003e range.max): range.max = proj return range Projecting a 2D convex polygon The extremum properties Definitions Let S(t) be the parametric equation of a convex shape.\\ It returns a point of the shape for a given t.
Let P(t) = DotProduct(S(t), axis).
P(t) is the projection of the points of that shape on a given axis.
Example : S(t) = r * cos(t) * i + r * sin(t) * j S(t) represents a circle with a radius of r, centered around the origin.
Properties of S(t) Continuous Periodic S(t) represents a closed set, so S(t) is continuous.
S(t) represents a closed set, so S(t) is periodic.
i.e. : if we choose a point and follow the line, we end up looping and coming back to that first point.
Properties of P(t) Continuous Periodic Maximum Minimum P(t) = DotProduct(S(t), axis).
S(t) is continuous. DotProduct is a continuous map.
So P(t) is continuous.
P(t) = DotProduct(S(t), axis).
S(t) is periodic, and axis is constant.
So P(t) is periodic too, with the same period as S(t).
Every local maximum of P(t) is equal to the maximum of P(t).
Every local minimum of P(t) is equal to the minimum of P(t).
Dichotomy As we saw before, once we find the extremum, we do not have to test the other vertices anymore.
The projections are also continuous, and there are only 2 extremums, so:
Python # Algorithm created by myself, and proud of it, hehe def NextIndex(shape, index): size = len(shape.vertices) return (index + 1) % size def PrevIndex(shape, index): size = len(shape.vertices) return (index - 1 + size) % size def GetMiddleIndex(shape, id1, id2): if (id1 \u003c id2): return (id1 + id2) / 2 else: size = len(shape.vertices) dist = size - (id1 - id2) return (id1 + dist / 2) % size def IsSmallerClockwise(shape, axis, index): p = ProjectPointOnAxis(shape.vertices[index], axis) pNext = ProjectPointOnAxis(shape.vertices[NextIndex(shape, index)], axis) return pNext \u003c p def IsSmallerAntiClockwise(shape, axis, index): p = ProjectPointOnAxis(shape.vertices[index], axis) pPrev = ProjectPointOnAxis(shape.vertices[PrevIndex(shape, index)], axis) return pPrev \u003c p # This function is tail recursive, so the compiler can optimize it out def SearchMinProjectionOnAxis(shape: Shape, axis: Vector, minIndex, maxIndex) -\u003e float: interval = maxIndex - minIndex i1 = minIndex i2 = GetMiddleIndex(shape, minIndex, maxIndex) # half v1 = shape.vertices[i1] v2 = shape.vertices[i2] p1 = ProjectPointOnAxis(v1, axis) p2 = ProjectPointOnAxis(v2, axis) if (p1 \u003c p2): # Go in the direction of p1 if (IsSmallerClockwise(shape, axis, i1)): return SearchMinProjectionOnAxis(shape, axis, i1, i2) # clockwise if (IsSmallerAntiClockwise(shape, axis, i1)): return SearchMinProjectionOnAxis(shape, axis, i2, i1) # anti clockwise # else, already at the end return p1 elif (p2 \u003c p1): # Go in the direction of p2 if (IsSmallerClockwise(shape, axis, i2)): return SearchMinProjectionOnAxis(shape, axis, i2, i1) # clockwise if (IsSmallerAntiClockwise(shape, axis, i2, i1)): return SearchMinProjectionOnAxis(shape, axis, i1, i2) # anti clockwise # else, already at the end return p2 # The same algorithm can be used to find the maximum projection. # Cases where projections are equal are not checked, but have to be and can be. # This program is not optimized, but has for goal to describe how the algorithm works. def ProjectShapeOnAxis(shape: Shape, axis: Vector) -\u003e Range: range = new Range() range.min = SearchMinProjectionOnAxis(shape, axis, 0, len(shape.vertices)) range.max = SearchMaxProjectionOnAxis(shape, axis, 0, len(shape.vertices)) return range Info This algorithm is very optimized for a high number of vertices. However, in practice, there are only a few games that have that many vertices in 2D. Due to the different checks, this algorithm is sure to be less optimized for a few amount of vertices.
Examples : A convex shape, with a first and a last vertex A vertex is chosen. There are as many vertices on the right as on the left We project the first vertex and the chosen vertex on the axis We select the vertex with the minimum projection, and evaluate in which direction the real minimum projection is We take the part of the circle between the first vertex and the chosen vertex that is in the direction of the minimum We repeat the algorithm, with the chosen vertex being the new last one A convex shape, that has a lot of vertices at one place We project the vertices ; the chosen vertex has the minimal projection We compute the direction of the real minimal projection We keep the part of the circle that was in that direction, and repeat Projecting an arbitrary 2D shape The brute force way An arbitrary shape can be constructed with the function S(t), described above. The brute force way of projecting the shape is just to project every point returned by that function. Of course, it is impossible to project every point. That is why we set a precision.
Info This method does not return the exact projection of the shape, but it is the best we can do without any more precisions on the shape. The performance is also horrible for what it is.
Python # shape.s(t) returns the vertices of shape # shape.s(t) is periodic with a period of 1 def ProjectShapeOnAxis(shape: Shape, axis: Vector, precision: int) -\u003e Range: range = new Range() range.min = Math.max() range.max = Math.min() step = 1 / precision for i in range(precision)) proj = ProjectPointOnAxis(shape.s(i*step), axis) if (proj \u003c range.min): range.min = proj if (proj \u003e range.max): range.max = proj return range The smarter way Being a convex shape, the same algorithm applied in the Dichotomy section can be used.
vertices[i] will be replaced by S(t).
Instead of adding 1 to the index, we will add a very small value to t.
Same for removing it.
We could also compute the derivative of P(t) to determine the direction, if possible.
Also, a maximum depth will be used instead of a precision to prevent infinite recursion.
Info This method does not return the exact projection of the shape either. However, the precision can be very accurate because of the depth we can easily increase thanks to the O(log(n)) complexity of the algorithm.
`,description:"",tags:null,title:"Projecting Shapes",uri:"/collisions/narrowphase/sat/projectshapes/index.html"},{content:` Algorithms This repository contains a list of algorithms.
Each algorithm has explainations and an associated code.
`,description:"",tags:null,title:"Projects",uri:"/index.html"},{content:" Physics Broad Phase List of broad phases : ",description:"",tags:null,title:"Broad Phase",uri:"/collisions/broadphase/index.html"},{content:" Why: Whether it is for 2D or 3D games, collisions are used a lot. Even the oldest games, like Tetris and Pacman, have some sort of collisions. After all this time, developers have found ways to simulate even more complex collisions : Box2D is opensource and was made by Erin Catto, but is not 3D PhysX was made by NVidia, but was discontinued Bullet, a 3D opensource collision library Chaos, recently developed by Unreal Engine Havok, used by Nintendo, Ubisoft, and others, but being premium And more... However, since the old days, new ways to represent shapes are being used: 2D boxes, moving freely (example : Mario) 2D Sprite pixels, for pixel to pixel collisions Complex 2D shapes, with multiple points 3D triangles, the mainstream way to represent 3D models Sign Distance Functions, being mathematical expressions of a shape And even more... The way to handle collisions is still evolving. Some games also require custom collisions to be optimal. Example : Minecraft only requires collisions between boxes and cylinders. The collision between chunks don't even have to be tested. References : ",description:"",tags:null,title:"Collisions",uri:"/collisions/index.html"},{content:`Definition : The narrow phase is
Chapter 1 `,description:"",tags:null,title:"EPA",uri:"/collisions/narrowphase/gjk/epa/index.html"},{content:` Getting the collision normal Getting the collision normal is pretty straightforward.
Indeed, the normal is the same as the separating axis.
Getting the MVT (Minimum Translation Vector) The MVT is equal to the overlapping interval of the projections between the two shapes.
Getting the collision point for 2D Let’s suppose we only have collisions between an edge and a point.
Every time, we project the shapes one the normal of an edge.
If we keep reference of which normal belongs to what shape, then we can find the edge that got collided.
Since we compute the MVT, we also compute the projection of that point on the axis.
It means we can retrieve it.
Code // to explicit out values #define out // This function can be optimized, but it shows how it works void ProjectShapeOnAxis(const Shape\u0026 shape, const Vector\u0026 axis, out float\u0026 min, out float\u0026 max, out Vector\u0026 minPoint, out Vector\u0026 maxPoint) const { points = shape.GetAllVertices(); min = Vector::DotProduct(points[0], axis); max = min; minPoint = points[0]; maxPoint = minPoint; for (const Vector\u0026 point : points) { float proj = Vec2::DotProduct(point, axis); if (proj \u003c min) { min = proj; minPoint = point; } if (proj \u003e max) { max = proj; maxPoint = point; } } } bool CheckCollision(const Shape\u0026 shape1, const Shape\u0026 shape2, Vector\u0026 colPoint, Vector\u0026 colNormal, float\u0026 mvt) { std::vector\u003cVector\u003e projectingAxes = GetProjectingAxes(shape1, shape2); float smallestOverlap = std::numeric_limits\u003cfloat\u003e::max(); Vector axisWithSmallestOverlap; for (const Vector\u0026 axis : projectingAxes) { Vector minPoint1; Vector maxPoint1; float minp1, maxp1; ProjectPolygonOnAxis(poly1, axis, minp1, maxp1, minPoint1, maxPoint1); Vector minPoint2; Vector maxPoint2; float minp2, maxp2; ProjectPolygonOnAxis(poly2, axis, minp2, maxp2, minPoint2, maxPoint2); if (!(maxp1 \u003e minp2 \u0026\u0026 maxp2 \u003e minp1)) { return false; } else { float minMaxProj = Min(maxp1, maxp2); float maxMinProj = Max(minp1, minp2); float overlap = minMaxProj - maxMinProj; if (overlap \u003c smallestOverlap) { Vector collisionPoint; if (axis.IsFromShape2()) { collisionPoint = maxPoint1; } else { collisionPoint = minPoint2; } // To prevent bugs when multiple edges with the same normal axis exist. // Indeed, the projection of the collision point should be included in the overlap; // or rather, be equal to one of the extremity. // We can add a small delta to be sure it works. float projCollisionPoint = Vector::DotProduct(collisionPoint, axis); if (projCollisionPoint \u003c= minMaxProj \u0026\u0026 projCollisionPoint \u003e= maxMinProj) { smallestOverlap = overlap; axisWithSmallestOverlap = axis; colPoint = collisionPoint; } } } } mvt = smallestOverlap; colNormal = axisWithSmallestOverlap.Normalized(); // colPoint is already set return true; } `,description:"",tags:null,title:"Getting output data",uri:"/collisions/narrowphase/sat/gettingoutputdata/index.html"},{content:`Definition : The narrow phase is
Chapter 1 `,description:"",tags:null,title:"GJK",uri:"/collisions/narrowphase/gjk/index.html"},{content:`Definition : The narrow phase is
Chapter 1 `,description:"",tags:null,title:"GSK",uri:"/collisions/narrowphase/gjk/gsk/index.html"},{content:`Definition : The narrow phase is
Chapter 1 `,description:"",tags:null,title:"MPR",uri:"/collisions/narrowphase/mpr/index.html"},{content:" Narrow Phase Definition: The narrow phase is the part when collisions between shapes will be tested with their actual geometry. It means these collisions are precise, but also performance heavy. The brute way to do things would be to test every triangle against each other. However, that would be too slow. Algorithms have been created to make it faster. Most of them use the properties of convex shapes. Requirements: For this phase to be useful, it must return : The point of collision The normal of the impact The penetrated distance between the two shapes Without that, we wouldn't be able to make a proper collision response afterwards. ",description:"",tags:null,title:"Narrow Phase",uri:"/collisions/narrowphase/index.html"},{content:" Separating Axis Theorem Summary : Theory In practice Get Projection Axes Projecting Shapes Getting output data Precomputing data Is Inside ",description:"",tags:["Collisions","Narrow Phase","Geometry"],title:"SAT",uri:"/collisions/narrowphase/sat/index.html"},{content:` Testing the same shape multiple times Let’s supposed we test 1 shape with 10 other shapes. Every time we will test a collision, we will project the 1st shape onto the axes. However, half of the axes will stay the same, because half of the axes will be computed from that 1st shape. That means we can precompute both the axes, but also the projections of the shape on half of the axes between the broadphase and the narrow phase.
Warning The previous algorithm would have returned as soon as it detects there are no collisions. This means less data could have been computed. By precomputing this data, we asssume shapes most likely collide to be efficient. This is one of the reasons the broadphase is so important. Otherwise, it could end up taking more performance instead.
Static Objects When objects are moving, we have to compute axes in world space again every frame.
However, when objects are not moving (i.e. static), their world position do not change.
That means the following won’t change:
half of the axes the projections of the shape on these axes We can cache that data.
Warning We have no idea when a collision would occur. Precomputing everything would cost a lot of memory, for collisions that might never happen.
Tip To optimize that, we could use world partitioning and only load / compute this data when getting close to the associated object.
Caching the separating axis You can save the separating axis for a pair for the next frame.
That way, at the next frame, you can test if that separating axis is still valid, and potentially have O(1) complexity.
C++ bool TestCollisionsWithSATOnAxis(const Shape\u0026 shape1, const Shape\u0026 shape2, const Axis\u0026 axis) { Range projection1 = shape1.ProjectOnAxis(axis); Range projection2 = shape2.ProjectOnAxis(axis); return DoRangesOverlap(projection1, projection2); } void NarrowPhaseBetween2Shapes(CollisionPair\u0026 collisionPair) { if (collisionPair.lastSeparatingAxis != nullptr \u0026\u0026 !TestCollisionsWithSATOnAxis(collisionPair.shape1, collisionPair.shape2, lastSeparatingAxis)) { return false; } TestCollisionsWithSAT(collisionPair.shape1, collisionPair.shape2, collisionPair.output) } `,description:"",tags:null,title:"Precomputing data",uri:"/collisions/narrowphase/sat/precomputingdata/index.html"},{content:` Properties of the projections If shape1 is colliding with shape2, then :
their respective projections will overlap on every axis If shape1 is not colliding with shape2, then :
their respective projections will not overlap on atleast 1 axis If shape1 is inside shape2, then :
the projection of shape1 will be included in the projection of shape2 on every axis If shape1 is not inside shape2, then :
the projection of shape1 will not be included in the projection of shape2 on atleast 1 axis Examples Shape1 is inside shape2. The projection of shape1 is always included in the projection of shape2 Shape1 is not inside shape2. The projection of shape1 is not always included in the projection of shape2 The algorithm Python def IsShape1InsideShape2(shape1: Shape, shape2: Shape) -\u003e bool axes = GetAxes(shape1, shape2) for axis in axes: projection1 = shape1.ProjectOnAxis(axis) projection2 = shape2.ProjectOnAxis(axis) if not IsProj1InsideProj2(projection1, projection2): return False return True `,description:"",tags:null,title:"Is Inside",uri:"/collisions/narrowphase/sat/isinside/index.html"},{content:"",description:"",tags:null,title:"Collisions",uri:"/tags/collisions/index.html"},{content:"",description:"",tags:null,title:"Geometry",uri:"/tags/geometry/index.html"},{content:"",description:"",tags:null,title:"Narrow Phase",uri:"/tags/narrow-phase/index.html"},{content:"",description:"",tags:null,title:"Tags",uri:"/tags/index.html"},{content:"",description:"",tags:null,title:"Categories",uri:"/categories/index.html"}]