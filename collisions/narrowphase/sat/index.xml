<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SAT on Documentation for Hugo Learn Theme</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/index.html</link><description>Recent content in SAT on Documentation for Hugo Learn Theme</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 11 Dec 2022 17:14:18 +0100</lastBuildDate><atom:link href="https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/index.xml" rel="self" type="application/rss+xml"/><item><title>Theory</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/theory/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/theory/index.html</guid><description>Hyperplane Separation Theorem For 2D Theorem: If two convex shapes do not collide, then, a straight line can separate them.
Contrapositive: If two convex shapes collide, then, there is no straight line separating them.
For 3D Theorem: If two convex shapes do not collide, then, a plane can separate them.
Contrapositive: If two convex shapes collide, then, there is no plane separating them.
Generalization for higher dimensions Theorem: If two convex shapes do not collide, then, a hyperplane can separate them.</description></item><item><title>In practice</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/inpractice/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/inpractice/index.html</guid><description>The brute force way We can project these shapes on every axis imaginable. If on one axis, the projections do not overlap, then there are no collisions. Otherwise, there is a collision.
C&amp;#43;&amp;#43; Python bool TestCollisionsWithSAT(const Shape&amp;amp; shape1, const Shape&amp;amp; shape2) { std::vector&amp;lt;Vector&amp;gt; axes = GetEveryAxisInTheWholeWorld(); for (const Vector&amp;amp; axis : axes) { Range projection1 = shape1.ProjectOnAxis(axis); Range projection2 = shape2.ProjectOnAxis(axis); // if there is a separating hyperplane if (!</description></item><item><title>Get Projection Axes</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/getprojectionaxes/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/getprojectionaxes/index.html</guid><description>Non unit axes optimization On the previous examples, for the projection to be accurate, the axes had to be unit vectors.
Let&amp;rsquo;s asssume an axis is not unit vectors.
That would mean all projections on that axis would be multiplied by the length of that axis.
However, the length of that axis is constant.
This means that the order of the projections are still preserved.
Since we&amp;rsquo;re only using that order, and not the values in themselves, we can take advantage of that.</description></item><item><title>Projecting Shapes</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/projectshapes/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/projectshapes/index.html</guid><description>Projecting a point The dot product can be used to project a point on an axis. Python def ProjectPointOnAxis(point, axis) -&amp;gt; float: return DotProduct(point, axis); 2D Dot Product Python def DotProduct(v1, v2) -&amp;gt; float: return v1.x * v2.x + v1.y * v2.y 3D Dot Product Python def DotProduct(v1, v2) -&amp;gt; float: return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z Dot Product Generalization Python def DotProduct(v1, v2) -&amp;gt; float: nbDimensions = v1.</description></item><item><title>Getting output data</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/gettingoutputdata/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/gettingoutputdata/index.html</guid><description>Getting the collision normal Getting the collision normal is pretty straightforward.
Indeed, the normal is the same as the separating axis.
Getting the MVT (Minimum Translation Vector) The MVT is equal to the overlapping interval of the projections between the two shapes.
Getting the collision point for 2D Let&amp;rsquo;s suppose we only have collisions between an edge and a point.
Every time, we project the shapes one the normal of an edge.</description></item><item><title>Precomputing data</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/precomputingdata/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/precomputingdata/index.html</guid><description>Testing the same shape multiple times Let&amp;rsquo;s supposed we test 1 shape with 10 other shapes. Every time we will test a collision, we will project the 1st shape onto the axes. However, half of the axes will stay the same, because half of the axes will be computed from that 1st shape. That means we can precompute both the axes, but also the projections of the shape on half of the axes between the broadphase and the narrow phase.</description></item><item><title>Is Inside</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/isinside/index.html</link><pubDate>Sun, 11 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/isinside/index.html</guid><description>Properties of the projections If shape1 is colliding with shape2, then :
their respective projections will overlap on every axis If shape1 is not colliding with shape2, then :
their respective projections will not overlap on atleast 1 axis If shape1 is inside shape2, then :
the projection of shape1 will be included in the projection of shape2 on every axis If shape1 is not inside shape2, then :</description></item><item><title>Minkowski And SAT</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/minkowskiandsat/index.html</link><pubDate>Tue, 20 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/minkowskiandsat/index.html</guid><description>The basic SAT algorithm Let&amp;rsquo;s get back at the original SAT implementation.
Note that the following works for every dimension.
C&amp;#43;&amp;#43; struct Range { float min, max; }; bool DoRangesOverlap(const Range&amp;amp; range1, const Range&amp;amp; range2) { return range1.max &amp;gt; range2.min &amp;amp;&amp;amp; range2.max &amp;gt; range1.min; } bool TestCollisionsWithSAT(const Shape&amp;amp; shape1, const Shape&amp;amp; shape2) { std::vector&amp;lt;Vector&amp;gt; axes = GetEveryAxisInTheWholeWorld(); for (const Vector&amp;amp; axis : axes) { Range projection1 = shape1.ProjectOnAxis(axis); Range projection2 = shape2.</description></item><item><title>Minkowski And Axes</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/minkoswkiandaxes/index.html</link><pubDate>Tue, 20 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/minkoswkiandaxes/index.html</guid><description>The basic SAT algorithm We saw previously that the SAT could be explained using the Minkowski sum.
C&amp;#43;&amp;#43; bool TestCollisionsWithSAT(const Shape&amp;amp; shape1, const Shape&amp;amp; shape2) { std::vector&amp;lt;Vector&amp;gt; axes = GetEveryAxisInTheWholeWorld(); Shape minkowskySum = shape1 - shape2; for (const Vector&amp;amp; axis : axes) { // The projection of the origin is 0 on any axis // So if the projection of the origin is not in projection of the Minkowski shape: if (minkowskySum.</description></item><item><title>Continuous collision</title><link>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/continuouscollision/index.html</link><pubDate>Tue, 20 Dec 2022 17:14:18 +0100</pubDate><guid>https://thomasprog.github.io/Algo-A-to-Z/collisions/narrowphase/sat/continuouscollision/index.html</guid><description>Continuous collision for non rotating shapes If the shapes don&amp;rsquo;t have any angular velocity, we can consider their separating axis never change.
We have both shapes projected on an axis; we just have to take time into account, and find the moment their ranges intersect.
This means we have a continuous collision&amp;hellip; but only when the shapes are not rotating.
The lower the rotation is, the more precise the collision is.</description></item></channel></rss>